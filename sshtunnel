#!/bin/bash

# Copyright 2013 Florian Bruhin <me@the-compiler.org>
# Manages SSH-tunnels via systemd
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>. 

g_config="/etc/sshtunnel.conf"
g_service="sshtunnel"

# Gets a config section from the config
# $1: name of the section
conf_section() {
    local secstart
    (( $# < 1 )) && return 2
    [[ -f "$g_config" && -r "$g_config" ]] || return 3
    unset secstart
    while read line; do # No -r by intention
        line="${line%%[;#]*}" # Strip inline comments
        [[ -z "$line" ]] && continue
        if [[ "$secstart" ]]; then
            [[ "$line" == '['*']' ]] && return 0 # End of a section
            echo "$line"
        fi
        [[ "$line" == "[$1]" ]] && secstart=1 # Start of a section
    done < "$g_config"
    [[ "$secstart" ]] && return 0 || return 1
}

# Gets a value of a key from the config
# $1: name of the section
# $2: name of the key
# $3: default value (optional)
conf_key() {
    (( $# < 2 )) && return 2
    while read -r line; do
        key="${line%%=*}"
        val="${line#*=}"
        [[ "$key" == "$2" ]] && echo "$val" && return 0
    done <<< "$(conf_section "$1")"
    [[ "$3" ]] && echo "$3"
    return 1
}

# Gets all sections from the config
conf_sections() {
    [[ -f "$g_config" && -r "$g_config" ]] || return 3
    while read -r line; do
        line="${line%%[;#]*}" # Strip inline comments
        if [[ "$line" == '['*']' ]]; then
            line="${line#\[}"
            line="${line%\]}"
            echo "$line"
        fi
    done < "$g_config"
}

# Prints an error message and exits
# $1: message
# $2: exit code (optional)
die() {
    echo "$1" >&2
    exit "${2:-1}"
}

# Prints an usage message
usage() {
    cat >&2 << EOF
Usage: $0 [-c <config>] <command> [<name>]
    -c: Use an alternate config file

    Commands:
        start <name>: Starts the tunnel named <name>
        stop <name>:  Stops the tunnel named <name>
        start-all:    Start all configured tunnels
        stop-all:     Stop running tunnels
        list:         List running tunnels
EOF
}

# Parses command line switches
# Call this with "$@"!
parseargs() {
    while :; do
        case "$1" in
            -c | --config)
                g_config="$2"
                shift 2
                ;;
            -h | --help)
                usage
                exit 0
                ;;
            --) # End of all options
                shift
                break
                ;;
            -*)
                usage
                die "Unknown option: $1"
                ;;
            *) # All parameters shifted
                break
                ;;
        esac
    done
    g_cmd="$1"
    shift
    case "$g_cmd" in
        start-all|stop-all|list) # Valid commands without arg
            ;;
        start|stop|systemd-start) # Valid commands with argument
            if (( $# < 1 )); then
                usage
                die "Command $g_cmd needs an argument!"
            else
                g_arg="$1"
            fi
            ;;
        "") # No command, default to list
            g_cmd=list
            ;;
        *) # Invalid command
            usage
            die "Invalid command: $g_cmd"
            ;;
    esac
    [[ -f "$g_config" && -r "$g_config" ]] || die "No config found!"
}

# Checks commands which need to be called as root
checkroot() {
    case "$g_cmd" in
        start|stop|start-all|stop-all)
            [[ "$UID" != 0 ]] && die "This command needs root privileges!"
            ;;
    esac
}

# Simple systemd wrapper to start tunnel
cmd_start() {
    systemctl start "${g_service}@${g_arg}.service"
}

# Simple systemd wrapper to stop tunnel
cmd_start() {
    systemctl stop "${g_service}@${g_arg}.service"
}

# List running tunnels
cmd_list() {
    systemctl list-units -t service -t loaded --full --no-legend --no-pager | while read name _; do
        if [[ "$name" == "${g_service}@"*.service ]]; then
            name="${name#"${g_service}@"}"
            name="${name%.service}"
            echo "$name"
        fi
    done
}

# Start all tunnels
cmd_start_all() {
    conf_sections | grep '^tunnel\.' | while read tunnel; do
        g_arg="${tunnel#tunnel.}"
        cmd_start
    done
}

# Stop all tunnels
cmd_stop_all() {
    cmd_list | while read g_arg; do
        cmd_stop
    done
}

# Actually start a tunnel, gets called from systemd
cmd_systemd_start() {
    local ssh
    local ssh_opts_global
    local monitoring
    local monitor_port
    local monitor_ssh_interval
    local monitor_ssh_count
    local user
    local host
    local port
    local tunnel
    local ssh_opts_local
    local name
    local autossh_env

    name="$g_arg"

    if ! conf_sections | grep '^tunnel\.' | grep -qF "tunnel.$name"; then
        die "Tunnel $name does not exist!"
    fi

    tunnel_cmd=()

    ssh=$(conf_key ssh ssh auto)
    if [[ "$ssh" == auto ]]; then
        which autossh &>/dev/null && ssh=autossh || ssh=ssh
    fi
    which "$ssh" &>/dev/null || die "$ssh not found"

    if [[ "$ssh" == *autossh* ]]; then
        read -ra autossh_env <<< "$(conf_section autossh | grep '^AUTOSSH_')"
        tunnel_cmd+=("env" "--" "${autossh_env[@]}" "$ssh")

        monitoring=$(conf_key autossh monitoring ssh)
        case "$monitoring" in
            port)
                monitor_port=$(conf_key autossh monitor_port 10000)
                tunnel_cmd+=("-M" "${monitor_port}")
                ;;
            ssh)
                monitor_ssh_interval=$(conf_key autossh monitor_ssh_interval 15)
                monitor_ssh_count=$(conf_key autossh monitor_ssh_count 3)
                tunnel_cmd+=("-M" "0")
                tunnel_cmd+=("-o" "ServerAliveInterval=$monitor_ssh_interval")
                tunnel_cmd+=("-o" "ServerAliveCountMax=$monitor_ssh_count")
                ;;
            none)
                tunnel_cmd+=("-M" "0")
                ;;
            *)
                die "Invalid value for monitoring!"
                ;;
        esac
    else
        tunnel_cmd+=("$ssh")
    fi

    port=$(conf_key "tunnel.$name" port 22)
    tunnel_cmd+=("-p" "$port")

    tunnel=$(conf_key "tunnel.$name" tunnel) || die "tunnel not set"
    tunnel_cmd+=("$tunnel")

    ssh_opts_global=$(conf_key ssh ssh_options)
    [[ "$ssh_opts_global" ]] && tunnel_cmd+=("$ssh_opts_global")
    ssh_opts_local=$(conf_key "tunnel.$name" ssh_options)
    [[ "$ssh_opts_local" ]] && tunnel_cmd+=("$ssh_opts_local")

    user=$(conf_key "tunnel.$name" user) || die "user not set"
    host=$(conf_key "tunnel.$name" host) || die "host not set"
    tunnel_cmd+=("$user@$host")

    echo "${tunnel_cmd[@]}"
}

parseargs "$@"
checkroot

case "$g_cmd" in
    start)         cmd_start         ;;
    stop)          cmd_stop          ;;
    start-all)     cmd_start_all     ;;
    stop-all)      cmd_stop_all      ;;
    list)          cmd_list          ;;
    systemd-start) cmd_systemd_start ;;
esac
