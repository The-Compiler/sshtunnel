#!/bin/bash

# Copyright 2013 Florian Bruhin <me@the-compiler.org>
# Manages SSH-tunnels via systemd
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>. 

g_config="/etc/sshtunnel.conf"
g_service="sshtunnel"

# Gets a config section from the config
# $1: name of the section
conf_section() {
    local secstart
    (( $# < 1 )) && return 2
    [[ -f "$g_config" && -r "$g_config" ]] || return 3
    unset secstart
    while read line; do # No -r by intention
        line="${line%%[;#]*}" # Strip inline comments
        [[ -z "$line" ]] && continue
        if [[ "$secstart" ]]; then
            [[ "$line" == '['*']' ]] && return 0 # End of a section
            echo "$line"
        fi
        [[ "$line" == "[$1]" ]] && secstart=1 # Start of a section
    done < "$g_config"
    [[ "$secstart" ]] && return 0 || return 1
}

# Gets a value of a key from the config
# $1: name of the section
# $2: name of the key
# $3: default value (optional)
conf_key() {
    (( $# < 2 )) && return 2
    while read -r line; do
        key="${line%%=*}"
        val="${line#*=}"
        [[ "$key" == "$2" ]] && echo "$val" && return 0
    done <<< "$(conf_section "$1")"
    [[ "$3" ]] && echo "$3"
    return 1
}

# Gets all sections from the config
conf_sections() {
    [[ -f "$g_config" && -r "$g_config" ]] || return 3
    while read line; do # No -r by intention
        line="${line%%[;#]*}" # Strip inline comments
        if [[ "$line" == '['*']' ]]; then
            line="${line#\[}"
            line="${line%\]}"
            echo "$line"
        fi
    done < "$g_config"
}

# Gets all keys from a section in the config
# $1: name of the section
conf_keys() {
    (( $# < 1 )) && return 2
    conf_section "$1" | while read -r line; do
        echo "${line%%=*}"
    done
}

# Prints an error message and exits
# $1: message
# $2: exit code (optional)
die() {
    echo "$1" >&2
    exit "${2:-0}"
}

# Prints an usage message
usage() {
    cat >&2 << EOF
Usage: $0 [-c <config>] <command> [<name>]
    -c: Use an alternate config file

    Commands:
        start <name>: Starts the tunnel named <name>
        stop <name>:  Stops the tunnel named <name>
        start-all:    Start all configured tunnels
        stop-all:     Stop running tunnels
        list:         List running tunnels
EOF
}

# Parses command line switches
# Call this with "$@"!
parseargs() {
    while :; do
        case "$1" in
            -c | --config)
                g_config="$2"
                shift 2
                ;;
            -h | --help)
                usage
                exit 0
                ;;
            --) # End of all options
                shift
                break
                ;;
            -*)
                usage
                die "Unknown option: $1"
                ;;
            *) # All parameters shifted
                break
                ;;
        esac
    done
    g_cmd="$1"
    shift
    case "$g_cmd" in
        start-all|stop-all|list) # Valid commands without argument
            ;;
        start|stop) # Valid commands with argument
            if (( $# < 1 )); then
                usage
                die "Command $g_cmd needs an argument!"
            else
                g_arg="$1"
            fi
            ;;
        "") # No command, default to list
            g_cmd=list
            ;;
        *) # Invalid command
            usage
            die "Invalid command: $g_cmd"
            ;;
    esac
}

# Checks commands which need to be called as root
checkroot() {
    case "$g_cmd" in
        start|stop|start-all|stop-all)
            [[ "$UID" != 0 ]] && die "This command needs root privileges!"
            ;;
    esac
}

# Simple systemd wrapper to start tunnel
cmd_start() {
    systemctl start "${g_service}@${g_arg}.service"
}

# Simple systemd wrapper to stop tunnel
cmd_start() {
    systemctl stop "${g_service}@${g_arg}.service"
}

# List running tunnels
cmd_list() {
    systemctl list-units -t service -t loaded --full --no-legend --no-pager | while read name _; do
        if [[ "$name" == "${g_service}@"*.service ]]; then
            name="${name#"${g_service}@"}"
            name="${name%.service}"
            echo "$name"
        fi
    done
}

# Start all tunnels
cmd_start_all() {
    config_sections | grep '^tunnel\.' | while read tunnel; do
        g_arg="${tunnel#tunnel.}"
        cmd_start
    done
}

# Stop all tunnels
cmd_stop_all() {
    cmd_list | while read g_arg; do
        cmd_stop
    done
}
parseargs "$@"
checkroot

case "$g_cmd" in
    start)         cmd_start         ;;
    stop)          cmd_stop          ;;
    start-all)     cmd_start_all     ;;
    stop-all)      cmd_stop_all      ;;
    list)          cmd_list          ;;
    systemd-start) cmd_systemd_start ;;
esac
